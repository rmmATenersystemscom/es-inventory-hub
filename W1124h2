# Database AI: Windows 11 24H2 Capability Assessment Implementation

**Subject**: Implement Windows 11 24H2 Capability Assessment for ES Inventory Hub Database

**Context**: Dashboard AI needs to track Windows 11 24H2 compatibility across all Windows devices in the ES Inventory Hub system. This requires adding new database fields and implementing post-collection assessment logic.

**Current Working Status**: 
- ES Inventory Hub v1.15.0 is fully operational
- Ninja collector runs every 45 minutes via systemd service
- Database schema includes `device_snapshot` table with device hardware information
- TPM and Secure Boot data is available via custom fields
- API server at `https://db-api.enersystems.com:5400` is operational

**Missing Requirements** (HIGH PRIORITY):

## 1. Database Schema Enhancement

### Add New Fields to `device_snapshot` Table

Add the following fields to the `device_snapshot` table:

```sql
-- Add Windows 11 24H2 capability fields to device_snapshot table
ALTER TABLE device_snapshot ADD COLUMN windows_11_24h2_capable BOOLEAN DEFAULT NULL;
ALTER TABLE device_snapshot ADD COLUMN windows_11_24h2_deficiencies JSONB DEFAULT '{}';
```

**Field Specifications**:
- `windows_11_24h2_capable`: Boolean field (true/false/NULL)
  - `true`: Device meets all Windows 11 24H2 requirements
  - `false`: Device fails one or more requirements
  - `NULL`: Assessment not yet performed or insufficient data
- `windows_11_24h2_deficiencies`: JSONB field containing detailed deficiency information
  - Structure similar to existing `details` field in `exceptions` table
  - Contains specific reasons why device fails 24H2 requirements
  - Includes remediation suggestions

### Example JSONB Structure for Deficiencies

```json
{
  "assessment_date": "2025-01-15T10:30:00Z",
  "verdict": "No",
  "deficiencies": [
    {
      "requirement": "CPU Support",
      "status": "FAIL",
      "current_value": "Intel Core i5-6500",
      "required": "Intel 8th gen or newer",
      "reason": "CPU generation 6 is below minimum requirement of generation 8",
      "remediation": "Hardware upgrade required - cannot be resolved via software"
    },
    {
      "requirement": "TPM 2.0",
      "status": "FAIL", 
      "current_value": "TPM 1.2",
      "required": "TPM 2.0",
      "reason": "TPM version 1.2 is below minimum requirement of 2.0",
      "remediation": "BIOS/UEFI update may enable TPM 2.0, otherwise hardware upgrade required"
    }
  ],
  "passed_requirements": [
    {
      "requirement": "64-bit OS",
      "status": "PASS",
      "current_value": "64-bit"
    },
    {
      "requirement": "Memory",
      "status": "PASS", 
      "current_value": "16.0 GiB",
      "required": "≥ 4 GiB"
    }
  ]
}
```

## 2. Post-Collection Assessment Function

### Create Assessment Script

Create a new Python script: `/opt/es-inventory-hub/collectors/assessments/windows_11_24h2_assessment.py`

**Requirements**:
- Run 45 minutes after Ninja collector completion
- Assess all Windows devices (desktops/laptops only)
- Use existing hardware data from device_snapshot table
- Implement the Windows 11 24H2 readiness logic (provided below)
- Update database with assessment results
- Log assessment results for debugging

### Windows 11 24H2 Assessment Logic

```python
def assess_windows_11_24h2_capability(device_data):
    """
    Assess Windows 11 24H2 capability based on device hardware data
    
    Input fields required:
    - OSArchitecture (string, e.g., "64-bit")
    - MemoryGiB (float, total RAM in GiB) 
    - StorageTotalGB (float, total storage capacity in GB)
    - CPUModel (string, e.g., "Intel(R) Core(TM) i7-8565U")
    - TPM.HasTPM (bool)
    - TPM.Enabled (bool) 
    - TPM.SpecVersionRaw (string, e.g., "2.0, 1.38, 0")
    - SecureBoot.Available (bool)
    - SecureBoot.Enabled (bool)
    """
    
    deficiencies = []
    passed_requirements = []
    verdict = "Yes"
    
    # 1. 64-bit OS requirement
    if device_data.get('os_architecture') != '64-bit':
        deficiencies.append({
            "requirement": "64-bit OS",
            "status": "FAIL",
            "current_value": device_data.get('os_architecture', 'Unknown'),
            "required": "64-bit",
            "reason": "Operating system must be 64-bit",
            "remediation": "Reinstall with 64-bit Windows"
        })
        verdict = "No"
    else:
        passed_requirements.append({
            "requirement": "64-bit OS", 
            "status": "PASS",
            "current_value": device_data.get('os_architecture')
        })
    
    # 2. Memory requirement (≥ 4 GiB, 8 GiB recommended)
    memory_gib = device_data.get('memory_gib', 0)
    if memory_gib < 4:
        deficiencies.append({
            "requirement": "Memory",
            "status": "FAIL",
            "current_value": f"{memory_gib} GiB",
            "required": "≥ 4 GiB (8 GiB recommended)",
            "reason": f"Insufficient memory: {memory_gib} GiB < 4 GiB minimum",
            "remediation": "Add more RAM to meet minimum requirement"
        })
        verdict = "No"
    else:
        passed_requirements.append({
            "requirement": "Memory",
            "status": "PASS", 
            "current_value": f"{memory_gib} GiB",
            "required": "≥ 4 GiB"
        })
    
    # 3. Storage requirement (≥ 64 GB)
    storage_gb = device_data.get('storage_total_gb', 0)
    if storage_gb < 64:
        deficiencies.append({
            "requirement": "Storage",
            "status": "FAIL",
            "current_value": f"{storage_gb} GB",
            "required": "≥ 64 GB",
            "reason": f"Insufficient storage: {storage_gb} GB < 64 GB minimum",
            "remediation": "Add more storage or free up space"
        })
        verdict = "No"
    else:
        passed_requirements.append({
            "requirement": "Storage",
            "status": "PASS",
            "current_value": f"{storage_gb} GB",
            "required": "≥ 64 GB"
        })
    
    # 4. CPU support requirement
    cpu_model = device_data.get('cpu_model', '')
    cpu_supported, cpu_reason = assess_cpu_support(cpu_model)
    if not cpu_supported:
        deficiencies.append({
            "requirement": "CPU Support",
            "status": "FAIL",
            "current_value": cpu_model,
            "required": "Intel 8th gen+, AMD Zen 2+, or Qualcomm Snapdragon",
            "reason": cpu_reason,
            "remediation": "Hardware upgrade required - cannot be resolved via software"
        })
        verdict = "No"
    else:
        passed_requirements.append({
            "requirement": "CPU Support",
            "status": "PASS",
            "current_value": cpu_model
        })
    
    # 5. TPM 2.0 requirement
    tpm_has = device_data.get('tpm_has', False)
    tpm_enabled = device_data.get('tpm_enabled', False)
    tpm_version = device_data.get('tpm_version', '')
    
    if not tpm_has:
        deficiencies.append({
            "requirement": "TPM 2.0",
            "status": "FAIL",
            "current_value": "No TPM detected",
            "required": "TPM 2.0 present and enabled",
            "reason": "No TPM module detected on device",
            "remediation": "Enable TPM in BIOS/UEFI or hardware upgrade required"
        })
        verdict = "No"
    elif not tpm_enabled:
        deficiencies.append({
            "requirement": "TPM 2.0", 
            "status": "FAIL",
            "current_value": "TPM present but disabled",
            "required": "TPM 2.0 present and enabled",
            "reason": "TPM is present but not enabled",
            "remediation": "Enable TPM in BIOS/UEFI settings"
        })
        verdict = "No"
    elif not is_tpm_2_0(tpm_version):
        deficiencies.append({
            "requirement": "TPM 2.0",
            "status": "FAIL", 
            "current_value": f"TPM {tpm_version}",
            "required": "TPM 2.0",
            "reason": f"TPM version {tpm_version} is below minimum requirement of 2.0",
            "remediation": "BIOS/UEFI update may enable TPM 2.0, otherwise hardware upgrade required"
        })
        verdict = "No"
    else:
        passed_requirements.append({
            "requirement": "TPM 2.0",
            "status": "PASS",
            "current_value": f"TPM {tpm_version} enabled"
        })
    
    # 6. Secure Boot requirement
    secure_boot_available = device_data.get('secure_boot_available', False)
    secure_boot_enabled = device_data.get('secure_boot_enabled', False)
    
    if not secure_boot_available:
        deficiencies.append({
            "requirement": "Secure Boot",
            "status": "FAIL",
            "current_value": "Secure Boot not available",
            "required": "Secure Boot supported and enabled",
            "reason": "Secure Boot is not supported on this device",
            "remediation": "Hardware upgrade required - device does not support Secure Boot"
        })
        verdict = "No"
    elif not secure_boot_enabled:
        deficiencies.append({
            "requirement": "Secure Boot",
            "status": "FAIL",
            "current_value": "Secure Boot available but disabled", 
            "required": "Secure Boot supported and enabled",
            "reason": "Secure Boot is available but not enabled",
            "remediation": "Enable Secure Boot in BIOS/UEFI settings"
        })
        verdict = "No"
    else:
        passed_requirements.append({
            "requirement": "Secure Boot",
            "status": "PASS",
            "current_value": "Secure Boot enabled"
        })
    
    # Handle insufficient data
    if not device_data.get('os_architecture') or not device_data.get('memory_gib'):
        verdict = "Maybe"
        deficiencies.append({
            "requirement": "Data Quality",
            "status": "INSUFFICIENT",
            "current_value": "Missing hardware data",
            "required": "Complete device information",
            "reason": "Insufficient device data for assessment",
            "remediation": "Ensure device is online and Ninja agent is reporting data"
        })
    
    return {
        "verdict": verdict,
        "deficiencies": deficiencies,
        "passed_requirements": passed_requirements,
        "assessment_date": datetime.utcnow().isoformat() + 'Z'
    }

def assess_cpu_support(cpu_model):
    """Assess CPU support for Windows 11 24H2"""
    if not cpu_model or cpu_model == 'N/A':
        return False, "CPU model not available"
    
    cpu_lower = cpu_model.lower()
    
    # Intel CPU support (8th gen or newer)
    if 'intel' in cpu_lower:
        # Check for generation indicators
        if '8th gen' in cpu_lower or '9th gen' in cpu_lower or '10th gen' in cpu_lower or '11th gen' in cpu_lower or '12th gen' in cpu_lower:
            return True, "Intel generation meets requirement"
        
        # Parse CPU model number
        import re
        # Look for patterns like i7-8565U, i5-1185G7, etc.
        match = re.search(r'i[3579]-(\d{4})', cpu_model)
        if match:
            cpu_number = int(match.group(1))
            if cpu_number >= 8000:  # 8th gen or newer
                return True, f"Intel CPU {cpu_number} meets requirement"
            else:
                return False, f"Intel CPU {cpu_number} is below minimum requirement (8th gen)"
    
    # AMD CPU support (Zen 2+ = Ryzen 3000/4000/5000+)
    elif 'amd' in cpu_lower or 'ryzen' in cpu_lower:
        if any(gen in cpu_lower for gen in ['3000', '4000', '5000', '6000', '7000']):
            return True, "AMD Ryzen generation meets requirement"
        elif '2000' in cpu_lower:
            return False, "AMD Ryzen 2000 series may not be fully supported"
        else:
            return False, "AMD CPU generation below minimum requirement"
    
    # Qualcomm/ARM support
    elif 'qualcomm' in cpu_lower or 'snapdragon' in cpu_lower:
        return True, "Qualcomm Snapdragon meets requirement"
    
    return False, f"Unsupported CPU: {cpu_model}"

def is_tpm_2_0(tpm_version):
    """Check if TPM version is 2.0 or higher"""
    if not tpm_version or tpm_version == 'N/A':
        return False
    
    # Parse TPM version string (e.g., "2.0, 1.38, 0")
    try:
        versions = [v.strip() for v in tpm_version.split(',')]
        # Remove "0" entries and check for "2.0"
        versions = [v for v in versions if v != '0']
        return '2.0' in versions
    except:
        return False
```

## 3. Systemd Service Integration

### Create Post-Collection Assessment Service

Create systemd service: `/etc/systemd/system/windows-11-24h2-assessment.service`

```ini
[Unit]
Description=Windows 11 24H2 Capability Assessment
After=es-inventory-ninja-collector.service
Requires=es-inventory-ninja-collector.service

[Service]
Type=oneshot
User=postgres
Group=postgres
WorkingDirectory=/opt/es-inventory-hub
ExecStart=/usr/bin/python3 /opt/es-inventory-hub/collectors/assessments/windows_11_24h2_assessment.py
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### Create Assessment Timer

Create systemd timer: `/etc/systemd/system/windows-11-24h2-assessment.timer`

```ini
[Unit]
Description=Run Windows 11 24H2 Assessment 45 minutes after Ninja collection
Requires=es-inventory-ninja-collector.service

[Timer]
OnCalendar=*-*-* 02:45:00,*-*-* 08:45:00,*-*-* 14:45:00,*-*-* 20:45:00
Persistent=true

[Install]
WantedBy=timers.target
```

## 4. API Endpoints for Dashboard Integration

### Add New API Endpoints

Extend the existing API server with these endpoints:

```python
# Add to /opt/es-inventory-hub/api/api_server.py

@app.route('/api/windows-11-24h2/status', methods=['GET'])
def get_windows_11_24h2_status():
    """Get Windows 11 24H2 compatibility status summary"""
    try:
        # Query database for Windows 11 24H2 assessment results
        query = """
        SELECT 
            COUNT(*) as total_windows_devices,
            COUNT(CASE WHEN windows_11_24h2_capable = true THEN 1 END) as compatible_devices,
            COUNT(CASE WHEN windows_11_24h2_capable = false THEN 1 END) as incompatible_devices,
            COUNT(CASE WHEN windows_11_24h2_capable IS NULL THEN 1 END) as not_assessed_devices
        FROM device_snapshot ds
        JOIN vendor v ON ds.vendor_id = v.id
        WHERE v.name = 'Ninja' 
        AND ds.snapshot_date = CURRENT_DATE
        AND ds.os_name ILIKE '%windows%'
        AND (ds.device_type_id IN (SELECT id FROM device_type WHERE name IN ('Desktop', 'Laptop')))
        """
        
        result = db.execute(query).fetchone()
        
        return jsonify({
            "total_windows_devices": result.total_windows_devices,
            "compatible_devices": result.compatible_devices,
            "incompatible_devices": result.incompatible_devices,
            "not_assessed_devices": result.not_assessed_devices,
            "compatibility_rate": round((result.compatible_devices / result.total_windows_devices * 100), 1) if result.total_windows_devices > 0 else 0,
            "last_assessment": get_last_assessment_date()
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/api/windows-11-24h2/incompatible', methods=['GET'])
def get_incompatible_devices():
    """Get list of devices that are incompatible with Windows 11 24H2"""
    try:
        query = """
        SELECT 
            ds.hostname,
            ds.display_name,
            ds.organization_name,
            ds.os_name,
            ds.windows_11_24h2_deficiencies
        FROM device_snapshot ds
        JOIN vendor v ON ds.vendor_id = v.id
        WHERE v.name = 'Ninja'
        AND ds.snapshot_date = CURRENT_DATE
        AND ds.windows_11_24h2_capable = false
        AND (ds.device_type_id IN (SELECT id FROM device_type WHERE name IN ('Desktop', 'Laptop')))
        ORDER BY ds.organization_name, ds.hostname
        """
        
        results = db.execute(query).fetchall()
        
        devices = []
        for row in results:
            deficiencies = json.loads(row.windows_11_24h2_deficiencies) if row.windows_11_24h2_deficiencies else {}
            devices.append({
                "hostname": row.hostname,
                "display_name": row.display_name,
                "organization": row.organization_name,
                "os_name": row.os_name,
                "deficiencies": deficiencies.get('deficiencies', []),
                "assessment_date": deficiencies.get('assessment_date', 'Unknown')
            })
        
        return jsonify({
            "incompatible_devices": devices,
            "total_count": len(devices)
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500
```

## 5. Database Migration Script

### Create Migration Script

Create: `/opt/es-inventory-hub/migrations/add_windows_11_24h2_fields.sql`

```sql
-- Add Windows 11 24H2 capability fields to device_snapshot table
-- Migration: Add Windows 11 24H2 Assessment Fields

BEGIN;

-- Add new columns to device_snapshot table
ALTER TABLE device_snapshot 
ADD COLUMN windows_11_24h2_capable BOOLEAN DEFAULT NULL,
ADD COLUMN windows_11_24h2_deficiencies JSONB DEFAULT '{}';

-- Add index for performance
CREATE INDEX idx_device_snapshot_windows_11_24h2_capable 
ON device_snapshot(windows_11_24h2_capable) 
WHERE windows_11_24h2_capable IS NOT NULL;

-- Add index for JSONB queries
CREATE INDEX idx_device_snapshot_windows_11_24h2_deficiencies 
ON device_snapshot USING GIN (windows_11_24h2_deficiencies);

COMMIT;
```

## 6. Testing Requirements

### Test Cases to Implement

1. **Database Schema Test**
   - Verify new columns are added correctly
   - Test JSONB field can store assessment data
   - Verify indexes are created

2. **Assessment Logic Test**
   - Test with various CPU models (Intel, AMD, Qualcomm)
   - Test TPM version parsing
   - Test Secure Boot logic
   - Test memory/storage requirements

3. **API Endpoint Test**
   - Test `/api/windows-11-24h2/status` endpoint
   - Test `/api/windows-11-24h2/incompatible` endpoint
   - Verify JSON responses are properly formatted

4. **Systemd Integration Test**
   - Verify service runs after Ninja collector
   - Test timer scheduling
   - Verify log output

## 7. Expected Impact and Benefits

### Dashboard AI Integration Benefits
- **New Variance Type**: "Windows 11 24H2 Incompatible" devices
- **Real-time Assessment**: Automatic assessment after each data collection
- **Detailed Deficiency Reporting**: Specific reasons why devices fail requirements
- **Organization Breakdown**: Incompatible devices grouped by organization
- **Export Capability**: CSV/PDF/Excel export of incompatible devices

### Business Value
- **Migration Planning**: Identify devices that need hardware upgrades
- **Cost Estimation**: Plan Windows 11 24H2 migration budget
- **Risk Assessment**: Understand scope of compatibility issues
- **Remediation Planning**: Prioritize device upgrades based on deficiencies

## 8. Technical Requirements

### Performance Considerations
- **Assessment Timing**: Run 45 minutes after Ninja collection to avoid conflicts
- **Database Indexing**: Proper indexes for efficient queries
- **JSONB Storage**: Efficient storage of deficiency details
- **API Response Time**: < 2 seconds for status queries

### Security Requirements
- **Database Access**: Use existing postgres user permissions
- **API Security**: Use existing HTTPS configuration
- **Data Privacy**: Assessment data follows same privacy rules as device data

## 9. Contact Information and Integration Status

**Current Integration Status**: 
- ES Inventory Hub API: `https://db-api.enersystems.com:5400` (operational)
- Database AI Server: 192.168.99.246 (accessible)
- Dashboard AI Server: 192.168.99.245 (ready for integration)

**Success Criteria**:
- ✅ New database fields added to device_snapshot table
- ✅ Assessment script runs automatically after Ninja collection
- ✅ API endpoints return Windows 11 24H2 compatibility data
- ✅ Dashboard AI can display incompatible device counts
- ✅ Export functionality includes Windows 11 24H2 data

**Priority Level**: HIGH - This enables critical Windows 11 24H2 migration planning

**Expected Completion**: 2-3 days for full implementation and testing

---

**This implementation will provide Dashboard AI with comprehensive Windows 11 24H2 compatibility data, enabling effective migration planning and device management across all organizations.**
